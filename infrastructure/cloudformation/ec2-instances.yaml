AWSTemplateFormatVersion: '2010-09-09'
Description: >
  motiv8me - Single-stack: API on EC2 behind ALB (ACM TLS),
  Frontend on S3 + CloudFront (ACM TLS), Route53 records for motiv8me.io + api.motiv8me.io,
  plus automatic frontend publish from UploadsBucket/deployment/motiv8-fe-dist.tar.gz (zero manual wiring).

Rules:
  MustBeUsEast1ForCloudFrontACM:
    Assertions:
      - Assert: !Equals [!Ref "AWS::Region", "us-east-1"]
        AssertDescription: "Deploy this stack in us-east-1 (CloudFront requires ACM cert in us-east-1)."

Parameters:
  EnvironmentName:
    Type: String
    Default: production

  WebAppInstanceType:
    Type: String
    Default: t3.small

  BatchInstanceType:
    Type: String
    Default: t3.xlarge

  KeyPairName:
    Type: AWS::EC2::KeyPair::KeyName

  VPCId:
    Type: String

  PublicSubnet1:
    Type: String

  PublicSubnet2:
    Type: String
    Description: Second public subnet (different AZ) required for ALB

  HostedZoneId:
    Type: String
    Description: Route53 Hosted Zone ID for motiv8me.io (e.g. Z123ABC...)

  RootDomainName:
    Type: String
    Default: motiv8me.io
    Description: Root domain for the frontend (CloudFront)

  ApiSubdomain:
    Type: String
    Default: api
    Description: Subdomain label for API (api.motiv8me.io)

  BatchSecurityGroup:
    Type: String
    Description: Existing SG for the batch instance

  # Must be INSTANCE PROFILE NAME (not ARN)
  InstanceProfileName:
    Type: String
    Description: IAM instance profile NAME (not ARN), e.g. production-motiv8-instance-profile
    Default: production-motiv8-instance-profile

  AppSecretsArn:
    Type: String

  UploadsBucket:
    Type: String
    Description: Bucket holding deployment artifacts under deployment/ (motiv8-fe-dist.tar.gz, motiv8-be.tar.gz)

  BatchControlRoleArn:
    Type: String

  RdsSecurityGroup:
    Type: String
    Description: Security group ID of the RDS database (to allow API instance connections)

  # NEW: bump to republish FE + invalidate CloudFront on stack update
  FrontendPublishVersion:
    Type: String
    Default: v1
    Description: Bump to trigger frontend republish (custom resource) and CloudFront invalidation.

  # NEW: bump to roll ASG (size=1) so it pulls latest backend artifact
  ApiDeployVersion:
    Type: String
    Default: v1
    Description: Bump to trigger LaunchTemplate/UserData change and roll the API instance (ASG size=1).

  # NEW: bump to replace batch instance with latest code
  BatchDeployVersion:
    Type: String
    Default: v1
    Description: Bump to trigger batch instance replacement with updated UserData/code.

Mappings:
  RegionMap:
    us-east-1:
      AMI: ami-0c101f26f147fa7fd
    us-west-2:
      AMI: ami-008fe2fc65df48dac

Resources:
  ApiDomainName:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub /${EnvironmentName}/motiv8me/api-domain
      Type: String
      Value: !Sub ${ApiSubdomain}.${RootDomainName}

  # ==========================================================
  # Frontend: S3 + CloudFront + ACM + Route53
  # ==========================================================
  FrontendBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub motiv8me-frontend-${AWS::AccountId}-${AWS::Region}
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        IgnorePublicAcls: true
        BlockPublicPolicy: true
        RestrictPublicBuckets: true
      OwnershipControls:
        Rules:
          - ObjectOwnership: BucketOwnerEnforced
      VersioningConfiguration:
        Status: Enabled

  FrontendOAC:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub ${EnvironmentName}-frontend-oac
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  FrontendCertificate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Ref RootDomainName
      ValidationMethod: DNS
      DomainValidationOptions:
        - DomainName: !Ref RootDomainName
          HostedZoneId: !Ref HostedZoneId
        - DomainName: !Sub www.${RootDomainName}
          HostedZoneId: !Ref HostedZoneId
      SubjectAlternativeNames:
        - !Sub www.${RootDomainName}

  FrontendDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        Comment: !Sub ${EnvironmentName} motiv8me frontend
        Aliases:
          - !Ref RootDomainName
          - !Sub www.${RootDomainName}
        DefaultRootObject: index.html
        Origins:
          - Id: s3-frontend-origin
            DomainName: !GetAtt FrontendBucket.RegionalDomainName
            OriginAccessControlId: !Ref FrontendOAC
            S3OriginConfig: {}
        DefaultCacheBehavior:
          TargetOriginId: s3-frontend-origin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods: [GET, HEAD, OPTIONS]
          CachedMethods: [GET, HEAD, OPTIONS]
          Compress: true
          ForwardedValues:
            QueryString: false
            Cookies:
              Forward: none
        CustomErrorResponses:
          - ErrorCode: 403
            ResponseCode: 200
            ResponsePagePath: /index.html
            ErrorCachingMinTTL: 0
          - ErrorCode: 404
            ResponseCode: 200
            ResponsePagePath: /index.html
            ErrorCachingMinTTL: 0
        ViewerCertificate:
          AcmCertificateArn: !Ref FrontendCertificate
          SslSupportMethod: sni-only
          MinimumProtocolVersion: TLSv1.2_2021

  FrontendBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref FrontendBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowCloudFrontReadOnly
            Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action:
              - s3:GetObject
            Resource: !Sub arn:aws:s3:::${FrontendBucket}/*
            Condition:
              StringEquals:
                AWS:SourceArn: !Sub arn:aws:cloudfront::${AWS::AccountId}:distribution/${FrontendDistribution}

  FrontendDnsRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Ref RootDomainName
      Type: A
      AliasTarget:
        DNSName: !GetAtt FrontendDistribution.DomainName
        HostedZoneId: Z2FDTNDATAQYW2

  FrontendWwwDnsRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Sub www.${RootDomainName}
      Type: A
      AliasTarget:
        DNSName: !GetAtt FrontendDistribution.DomainName
        HostedZoneId: Z2FDTNDATAQYW2
  # SES setup
  SesDomainIdentity:
    Type: AWS::SES::EmailIdentity
    Properties:
      EmailIdentity: !Ref RootDomainName
      DkimSigningAttributes:
        NextSigningKeyLength: RSA_2048_BIT
      Tags:
        - Key: app
          Value: motiv8me
        - Key: env
          Value: !Ref EnvironmentName

  SesDkimRecords:
    Type: AWS::Route53::RecordSetGroup
    Properties:
      HostedZoneId: !Ref HostedZoneId
      RecordSets:
        - Name: !GetAtt SesDomainIdentity.DkimDNSTokenName1
          Type: CNAME
          TTL: 300
          ResourceRecords: [!GetAtt SesDomainIdentity.DkimDNSTokenValue1]
        - Name: !GetAtt SesDomainIdentity.DkimDNSTokenName2
          Type: CNAME
          TTL: 300
          ResourceRecords: [!GetAtt SesDomainIdentity.DkimDNSTokenValue2]
        - Name: !GetAtt SesDomainIdentity.DkimDNSTokenName3
          Type: CNAME
          TTL: 300
          ResourceRecords: [!GetAtt SesDomainIdentity.DkimDNSTokenValue3]

  SesSpfRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Ref RootDomainName
      Type: TXT
      TTL: 300
      ResourceRecords:
        - "\"v=spf1 include:amazonses.com -all\""

  SesDmarcRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Sub _dmarc.${RootDomainName}
      Type: TXT
      TTL: 300
      # start p=none; tighten later once you confirm deliverability
      ResourceRecords:
        - "\"v=DMARC1; p=none; adkim=s; aspf=s\""

  # ==========================================================
  # API: ALB + ACM + ASG(size=1) (uvicorn :8000) + Route53
  # ==========================================================
  ApiAlbSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Allow HTTP/HTTPS to API ALB
      VpcId: !Ref VPCId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0

  ApiInstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: API instance SG - only ALB can reach uvicorn
      VpcId: !Ref VPCId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 8000
          ToPort: 8000
          SourceSecurityGroupId: !Ref ApiAlbSecurityGroup
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0

  # Allow API instances to connect to RDS
  RdsIngressFromApiInstances:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref RdsSecurityGroup
      IpProtocol: tcp
      FromPort: 5432
      ToPort: 5432
      SourceSecurityGroupId: !Ref ApiInstanceSecurityGroup

  ApiCertificate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Sub ${ApiSubdomain}.${RootDomainName}
      ValidationMethod: DNS
      DomainValidationOptions:
        - DomainName: !Sub ${ApiSubdomain}.${RootDomainName}
          HostedZoneId: !Ref HostedZoneId

  ApiLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub ${EnvironmentName}-api-alb
      Scheme: internet-facing
      Type: application
      Subnets:
        - !Ref PublicSubnet1
        - !Ref PublicSubnet2
      SecurityGroups:
        - !Ref ApiAlbSecurityGroup

  ApiTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub ${EnvironmentName}-api-tg
      VpcId: !Ref VPCId
      TargetType: instance
      Protocol: HTTP
      Port: 8000
      HealthCheckProtocol: HTTP
      HealthCheckPath: /health
      Matcher:
        HttpCode: "200-399"

  ApiHttpListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref ApiLoadBalancer
      Port: 80
      Protocol: HTTP
      DefaultActions:
        - Type: redirect
          RedirectConfig:
            Protocol: HTTPS
            Port: "443"
            StatusCode: HTTP_301

  ApiHttpsListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref ApiLoadBalancer
      Port: 443
      Protocol: HTTPS
      Certificates:
        - CertificateArn: !Ref ApiCertificate
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref ApiTargetGroup

  ApiDnsRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Sub ${ApiSubdomain}.${RootDomainName}
      Type: A
      AliasTarget:
        DNSName: !GetAtt ApiLoadBalancer.DNSName
        HostedZoneId: !GetAtt ApiLoadBalancer.CanonicalHostedZoneID

  # ==========================================================
  # Web App LaunchTemplate + ASG (Desired=1)
  # Rolling update triggered by ApiDeployVersion/UserData changes.
  # NOTE: With MaxSize=1 and MinInstancesInService=0, updates can briefly go unavailable.
  # ==========================================================
  WebAppLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub ${EnvironmentName}-webapp-lt
      LaunchTemplateData:
        InstanceType: !Ref WebAppInstanceType
        KeyName: !Ref KeyPairName
        ImageId: !FindInMap [RegionMap, !Ref 'AWS::Region', AMI]
        IamInstanceProfile:
          Name: !Ref InstanceProfileName
        SecurityGroupIds:
          - !Ref ApiInstanceSecurityGroup
        BlockDeviceMappings:
          - DeviceName: /dev/xvda
            Ebs:
              VolumeSize: 30
              VolumeType: gp3
              DeleteOnTermination: true
        TagSpecifications:
          - ResourceType: instance
            Tags:
              - Key: Name
                Value: !Sub ${EnvironmentName}-webapp
              - Key: Role
                Value: api
              - Key: DeployVersion
                Value: !Ref ApiDeployVersion
          - ResourceType: volume
            Tags:
              - Key: Role
                Value: api
        UserData:
          Fn::Base64: !Sub |
            #!/bin/bash -xe
            exec > >(tee /var/log/user-data.log|logger -t user-data -s 2>/dev/console) 2>&1

            echo "ApiDeployVersion=${ApiDeployVersion}"
            echo "${ApiDeployVersion}" > /etc/motiv8-deploy-version

            yum update -y
            yum install -y awscli aws-cfn-bootstrap git python3 python3-pip python3-devel gcc

            mkdir -p /app
            aws s3 cp s3://${UploadsBucket}/deployment/motiv8-be.tar.gz /tmp/motiv8-be.tar.gz --region ${AWS::Region}

            # Ensure old code can't linger
            rm -rf /app/motiv8-be
            tar -xzf /tmp/motiv8-be.tar.gz -C /app
            rm /tmp/motiv8-be.tar.gz

            cd /app/motiv8-be
            python3 -m venv venv
            source venv/bin/activate
            pip install --upgrade pip
            pip install -r requirements-webapp.txt

            # Write secrets to an env file (raw .env for app tooling)
            aws secretsmanager get-secret-value \
              --secret-id ${AppSecretsArn} \
              --region ${AWS::Region} \
              --query SecretString \
              --output text \
            | python3 -c 'import json,sys; s=json.load(sys.stdin); [print(f"{k}={v}") for k,v in s.items()]' \
            > /app/motiv8-be/.env

            echo "CORS_ALLOWED_ORIGINS=https://${RootDomainName}" >> /app/motiv8-be/.env
            echo "AWS_REGION=${AWS::Region}" >> /app/motiv8-be/.env

            # Create a systemd-safe env file (quotes + spaces handled)
            python3 -c 'import shlex; from pathlib import Path
            src=Path("/app/motiv8-be/.env").read_text().splitlines()
            out=[]
            for line in src:
              line=line.strip()
              if not line or line.startswith("#") or "=" not in line:
                continue
              k,v=line.split("=",1)
              out.append(f"{k.strip()}={shlex.quote(v.strip())}")
            Path("/etc/motiv8-webapp.env").write_text("\n".join(out)+ "\n")
            '

            chmod 600 /etc/motiv8-webapp.env

            # Run database migrations before starting the app
            echo "Running database migrations..."
            source venv/bin/activate
            python3 migrate.py || { echo "Migration failed"; exit 1; }

            cat > /etc/systemd/system/motiv8-webapp.service << 'SVCEOF'
            [Unit]
            Description=motiv8me Web API
            After=network.target

            [Service]
            Type=simple
            User=root
            WorkingDirectory=/app/motiv8-be
            EnvironmentFile=/etc/motiv8-webapp.env
            Environment="PATH=/app/motiv8-be/venv/bin:/usr/local/bin:/usr/bin:/bin"
            ExecStart=/app/motiv8-be/venv/bin/uvicorn main:app --host 0.0.0.0 --port 8000 --proxy-headers --forwarded-allow-ips="*"
            Restart=always
            RestartSec=10

            [Install]
            WantedBy=multi-user.target
            SVCEOF

            systemctl daemon-reload
            systemctl enable motiv8-webapp.service
            systemctl restart motiv8-webapp.service

            sleep 3
            systemctl is-active motiv8-webapp.service

            # Always signal CloudFormation on exit (success/failure)
            CFN_SIGNAL="/opt/aws/bin/cfn-signal"
            STACK_NAME="${AWS::StackName}"
            RESOURCE_NAME="WebAppAutoScalingGroupV2"
            REGION="${AWS::Region}"

            # If anything fails after this point, send a FAILURE signal
            trap 'rc=$?; echo "UserData failed with rc=$rc"; $CFN_SIGNAL -e $rc --stack "$STACK_NAME" --resource "$RESOURCE_NAME" --region "$REGION" || true; exit $rc' ERR

            echo "Waiting for app healthcheck to pass before signaling CloudFormation..."
            for i in $(seq 1 60); do
              if curl -fsS "http://127.0.0.1:8000/health" >/dev/null 2>&1; then
                echo "Healthcheck OK"
                break
              fi
              echo "Healthcheck not ready yet ($i/60) ..."
              sleep 5
            done

            # Final check: if still failing, trigger trap via non-zero exit
            curl -fsS "http://127.0.0.1:8000/health" >/dev/null

            echo "Signaling CloudFormation SUCCESS for $RESOURCE_NAME"
            $CFN_SIGNAL -e 0 --stack "$STACK_NAME" --resource "$RESOURCE_NAME" --region "$REGION"

            # Debug proof: show what systemd loaded + what process has
            systemctl show motiv8-webapp.service -p Environment | sed 's/Environment=//' | head -c 2000 || true

  WebAppAutoScalingGroupV2:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      AutoScalingGroupName: !Sub webapp-asg
      VPCZoneIdentifier:
        - !Ref PublicSubnet1
        - !Ref PublicSubnet2
      MinSize: "1"
      MaxSize: "2"
      DesiredCapacity: "1"
      HealthCheckType: ELB
      HealthCheckGracePeriod: 900
      TargetGroupARNs:
        - !Ref ApiTargetGroup
      LaunchTemplate:
        LaunchTemplateId: !Ref WebAppLaunchTemplate
        Version: !GetAtt WebAppLaunchTemplate.LatestVersionNumber
      Tags:
        - Key: Role
          Value: api
          PropagateAtLaunch: true
        - Key: DeployVersion
          Value: !Ref ApiDeployVersion
          PropagateAtLaunch: true
    UpdatePolicy:
      AutoScalingRollingUpdate:
        MinInstancesInService: 1   # <-- never go below 1 serving
        MaxBatchSize: 1
        PauseTime: PT15M
        WaitOnResourceSignals: true
        SuspendProcesses:
          - HealthCheck
          - ReplaceUnhealthy
          - AZRebalance
          - AlarmNotification
          - ScheduledActions

    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
        Count: 1

  # ==========================================================
  # Batch Processing EC2 Instance (Scheduled)
  # ==========================================================
  BatchInstance:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: !Ref BatchInstanceType
      KeyName: !Ref KeyPairName
      ImageId: !FindInMap [RegionMap, !Ref 'AWS::Region', AMI]
      IamInstanceProfile: !Ref InstanceProfileName
      SecurityGroupIds:
        - !Ref BatchSecurityGroup
      SubnetId: !Ref PublicSubnet1
      BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            VolumeSize: 50
            VolumeType: gp3
            DeleteOnTermination: true
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName}-batch
        - Key: AutoShutdown
          Value: 'true'
        - Key: Version
          Value: !Ref BatchDeployVersion
        - Key: BatchEmailFilter
          Value: 'jacksoncook73@gmail.com'
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -xe
          exec > >(tee /var/log/user-data.log | logger -t user-data -s 2>/dev/console) 2>&1

          # --------------------------------------------------------------------
          # Metadata
          # --------------------------------------------------------------------
          # Deploy version: ${BatchDeployVersion}
          export BATCH_DEPLOY_VERSION="${BatchDeployVersion}"
          echo "Batch Deploy Version: $BATCH_DEPLOY_VERSION"

          # --------------------------------------------------------------------
          # Base packages
          # --------------------------------------------------------------------
          yum update -y
          yum install -y \
            awscli \
            aws-cfn-bootstrap \
            git \
            python3 \
            python3-pip \
            python3-devel \
            gcc \
            gcc-c++ \
            make

          yum install -y mesa-libGL glib2 libSM libXrender libXext

          # --------------------------------------------------------------------
          # 1) ONE-TIME provisioning at first boot: code + venv in /opt/motiv8-be
          # --------------------------------------------------------------------
          mkdir -p /opt

          aws s3 cp \
            s3://${UploadsBucket}/deployment/motiv8-be.tar.gz \
            /tmp/motiv8-be.tar.gz \
            --region ${AWS::Region}

          rm -rf /opt/motiv8-be
          tar -xzf /tmp/motiv8-be.tar.gz -C /opt
          rm /tmp/motiv8-be.tar.gz

          cd /opt/motiv8-be

          python3 -m venv venv
          source venv/bin/activate
          pip install --upgrade pip
          pip install -r requirements.txt

          # Ensure the script in the artifact is executable
          chmod +x /opt/motiv8-be/run-batch-job.sh

          # --------------------------------------------------------------------
          # 2) SINGLE systemd oneshot service
          #    - does boot prep every time
          #    - runs batch job
          #    - no dependency cycles
          # --------------------------------------------------------------------
          cat > /etc/systemd/system/motiv8-batch.service << 'SVCEOF'
          [Unit]
          Description=motiv8me Batch Job
          After=network-online.target cloud-final.service
          Wants=network-online.target cloud-final.service

          [Service]
          Type=oneshot
          Environment="APP_SECRETS_ARN=${AppSecretsArn}"
          Environment="AWS_REGION=${AWS::Region}"
          Environment="PYTHONUNBUFFERED=1"
          Environment="UPLOADS_BUCKET=${UploadsBucket}"
          Environment="BATCH_DEPLOY_VERSION=${BatchDeployVersion}"

          # --- ensure runner is always correct ---
          ExecStartPre=/bin/bash -lc '\
            set -euo pipefail; \
            mkdir -p /app/batch; \
            if [ ! -f /opt/motiv8-be/run-batch-job.sh ]; then \
              echo "ERROR: /opt/motiv8-be/run-batch-job.sh missing"; \
              exit 1; \
            fi; \
            chmod +x /opt/motiv8-be/run-batch-job.sh; \
            ln -sf /opt/motiv8-be/run-batch-job.sh /app/batch/run-batch.sh; \
            ls -la /app/batch/run-batch.sh \
          '

          # --- run batch ---
          ExecStart=/bin/bash -lc '/app/batch/run-batch.sh'

          # --- logging + long-running safety ---
          StandardOutput=journal+console
          StandardError=journal+console
          TimeoutStartSec=0
          KillMode=process

          [Install]
          WantedBy=multi-user.target
          SVCEOF

          # --------------------------------------------------------------------
          # 3) Enable and run batch job on this boot
          # --------------------------------------------------------------------
          systemctl daemon-reload
          systemctl enable motiv8-batch.service
          systemctl start --no-block motiv8-batch.service

          # --------------------------------------------------------------------
          # 4) CloudFormation signal
          # --------------------------------------------------------------------
          /opt/aws/bin/cfn-signal \
            -e $? \
            --stack ${AWS::StackName} \
            --resource BatchInstance \
            --region ${AWS::Region}


  # ==========================================================
  # Lambda Function for Starting Batch Instance
  # ==========================================================
  StartBatchInstanceFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${EnvironmentName}-start-batch-instance
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !Ref BatchControlRoleArn
      Timeout: 60
      Environment:
        Variables:
          BATCH_INSTANCE_ID: !Ref BatchInstance
      Code:
        ZipFile: |
          import boto3
          import os
          import json

          ec2 = boto3.client('ec2')

          def lambda_handler(event, context):
              instance_id = os.environ['BATCH_INSTANCE_ID']

              # Extract optional email parameter from event
              email = None
              if 'email' in event:
                  email = event['email']
              elif 'body' in event:
                  # Support API Gateway integration
                  try:
                      body = json.loads(event['body']) if isinstance(event['body'], str) else event['body']
                      email = body.get('email')
                  except:
                      pass

              print(f'Starting batch instance: {instance_id}')
              if email:
                  print(f'Setting email filter tag: {email}')
                  # Set the email tag BEFORE starting the instance to avoid race condition
                  ec2.create_tags(
                      Resources=[instance_id],
                      Tags=[{'Key': 'BatchEmailFilter', 'Value': email}]
                  )
              else:
                  # Remove any existing email filter tag
                  try:
                      ec2.delete_tags(
                          Resources=[instance_id],
                          Tags=[{'Key': 'BatchEmailFilter'}]
                      )
                  except:
                      pass  # Tag might not exist, that's fine

              # Start the instance after setting the tag
              ec2.start_instances(InstanceIds=[instance_id])

              return {
                  'statusCode': 200,
                  'body': f'Started instance {instance_id}' + (f' with email filter: {email}' if email else '')
              }

  DailyBatchRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub ${EnvironmentName}-daily-batch-trigger
      Description: Trigger daily batch job at 3 PM UTC (10 AM EST / 7 AM PST)
      ScheduleExpression: 'cron(0 15 * * ? *)'
      State: ENABLED
      Targets:
        - Arn: !GetAtt StartBatchInstanceFunction.Arn
          Id: StartBatchInstance

  PermissionForEventsToInvokeLambda:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref StartBatchInstanceFunction
      Action: 'lambda:InvokeFunction'
      Principal: events.amazonaws.com
      SourceArn: !GetAtt DailyBatchRule.Arn

  # ==========================================================
  # Frontend autopublish: UploadsBucket tar.gz -> FrontendBucket + CloudFront invalidation
  # ==========================================================
  FrontendPublishRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${EnvironmentName}-frontend-publish-role-${AWS::Region}
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: FrontendPublishPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: [s3:GetObject, s3:ListBucket]
                Resource:
                  - !Sub arn:aws:s3:::${UploadsBucket}
                  - !Sub arn:aws:s3:::${UploadsBucket}/*
              - Effect: Allow
                Action: [s3:PutObject, s3:DeleteObject, s3:ListBucket]
                Resource:
                  - !Sub arn:aws:s3:::${FrontendBucket}
                  - !Sub arn:aws:s3:::${FrontendBucket}/*
              - Effect: Allow
                Action: [cloudfront:CreateInvalidation]
                Resource: !Sub arn:aws:cloudfront::${AWS::AccountId}:distribution/${FrontendDistribution}

  FrontendPublishFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${EnvironmentName}-frontend-publish
      Runtime: python3.11
      Handler: index.handler
      Role: !GetAtt FrontendPublishRole.Arn
      Timeout: 300
      MemorySize: 512
      Environment:
        Variables:
          SRC_BUCKET: !Ref UploadsBucket
          SRC_KEY: deployment/motiv8-fe-dist.tar.gz
          DST_BUCKET: !Ref FrontendBucket
          DISTRIBUTION_ID: !Ref FrontendDistribution
      Code:
        ZipFile: |
          import boto3, os, tarfile, tempfile, mimetypes, urllib.request, json, traceback
          s3 = boto3.client("s3")
          cf = boto3.client("cloudfront")

          def respond(event, context, status, reason=None, data=None, physical_id=None):
              resp_url = event["ResponseURL"]
              body = {
                  "Status": status,
                  "Reason": reason or f"See CloudWatch logs: {context.log_stream_name}",
                  "PhysicalResourceId": physical_id or context.log_stream_name,
                  "StackId": event["StackId"],
                  "RequestId": event["RequestId"],
                  "LogicalResourceId": event["LogicalResourceId"],
                  "Data": data or {}
              }
              req = urllib.request.Request(resp_url, data=json.dumps(body).encode("utf-8"), method="PUT")
              req.add_header("Content-Type", "")
              req.add_header("Content-Length", str(len(req.data)))
              urllib.request.urlopen(req)

          def guess_content_type(key: str) -> str:
              ct, _ = mimetypes.guess_type(key)
              return ct or "application/octet-stream"

          def cache_control_for(key: str) -> str:
              if key.endswith("index.html"):
                  return "no-cache, no-store, must-revalidate"
              if key.startswith("assets/") or "/assets/" in key:
                  return "public, max-age=31536000, immutable"
              return "public, max-age=3600"

          def empty_bucket(bucket: str):
              paginator = s3.get_paginator("list_objects_v2")
              for page in paginator.paginate(Bucket=bucket):
                  objs = [{"Key": o["Key"]} for o in page.get("Contents", [])]
                  if objs:
                      s3.delete_objects(Bucket=bucket, Delete={"Objects": objs})

          def handler(event, context):
              try:
                  req_type = event.get("RequestType", "Create")
                  src_bucket = os.environ["SRC_BUCKET"]
                  src_key = os.environ["SRC_KEY"]
                  dst_bucket = os.environ["DST_BUCKET"]
                  dist_id = os.environ["DISTRIBUTION_ID"]

                  if req_type == "Delete":
                      respond(event, context, "SUCCESS", data={"Message": "No-op on Delete"})
                      return

                  empty_bucket(dst_bucket)

                  with tempfile.TemporaryDirectory() as td:
                      tgz_path = os.path.join(td, "fe.tar.gz")
                      s3.download_file(src_bucket, src_key, tgz_path)

                      with tarfile.open(tgz_path, "r:gz") as tar:
                          members = [m for m in tar.getmembers() if m.isfile()]
                          for m in members:
                              name = m.name.lstrip("./")
                              parts = name.split("/", 1)
                              if len(parts) == 2 and parts[0] in ("dist", "build"):
                                  key = parts[1]
                              else:
                                  key = name
                              if not key or key.endswith("/"):
                                  continue
                              f = tar.extractfile(m)
                              if not f:
                                  continue
                              body = f.read()
                              s3.put_object(
                                  Bucket=dst_bucket,
                                  Key=key,
                                  Body=body,
                                  ContentType=guess_content_type(key),
                                  CacheControl=cache_control_for(key),
                              )

                  cf.create_invalidation(
                      DistributionId=dist_id,
                      InvalidationBatch={
                          "CallerReference": context.aws_request_id,
                          "Paths": {"Quantity": 2, "Items": ["/index.html", "/*"]},
                      },
                  )

                  respond(event, context, "SUCCESS", data={"Message": "Frontend published + invalidated"})
              except Exception as e:
                  traceback.print_exc()
                  respond(event, context, "FAILED", reason=str(e))

  FrontendPublishCustomResource:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt FrontendPublishFunction.Arn
      PublishVersion: !Ref FrontendPublishVersion

Outputs:
  FrontendUrl:
    Description: Frontend URL (CloudFront)
    Value: !Sub https://${RootDomainName}

  FrontendBucketName:
    Description: S3 bucket hosting frontend assets (private; CloudFront only)
    Value: !Ref FrontendBucket

  CloudFrontDomainName:
    Description: CloudFront distribution domain name
    Value: !GetAtt FrontendDistribution.DomainName

  ApiUrl:
    Description: API URL (ALB + ACM)
    Value: !Sub https://${ApiSubdomain}.${RootDomainName}

  ApiAlbDns:
    Description: API ALB DNS
    Value: !GetAtt ApiLoadBalancer.DNSName

  WebAppAsgName:
    Description: API AutoScaling Group name (DesiredCapacity=1)
    Value: !Ref WebAppAutoScalingGroupV2

  BatchInstanceId:
    Description: Batch Instance ID
    Value: !Ref BatchInstance
